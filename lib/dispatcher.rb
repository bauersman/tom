require "em-synchrony/fiber_iterator"

module Tom
  class Dispatcher

    # Dispatches this request to all adapters that registered
    # for the route and then calls the merger for this route
    # to compose a response
    #
    # @param env [Array] A rack env object
    # @return (see #merge)
    def self.dispatch(env)
      route, method = route_and_method(env)
      adapters = Tom.adapters_for_route(route, method)
      return [404, {}, '{reason: "No adapters for this route"}'] if adapters.empty?

      # Hit APIs. All at the same time. Oh, mygodd!
      responses = {}
      Tom::LOG.info "#{env['REQUEST_METHOD'].upcase} #{env['REQUEST_URI']}"
      Tom::LOG.info "Dispatching to:"
      EM::Synchrony::FiberIterator.new(adapters, adapters.count).map do |clazz|
        Tom::LOG.info "  -> #{clazz}"
        (responses[clazz] ||= []) <<  clazz.new.handle(env)
      end

      merged = merge(env, responses)
      Tom::LOG.info "-------------------------------------------------------n"
      merged
    end

    # Takes a request (rack env) and a couple of responses
    # generated by api adapters and composes a response for the
    # client.
    #
    # The merger used depends on the route.
    #
    # @param env [Array] A rack env object
    # @return [Array] The merged result of all requests
    #   made as an array of status code, headers and body, e.g.
    #   `[200, {}, "Hi!"]`
    def self.merge(env, responses)
      route, method = route_and_method(env)
      merger = Tom.merger_for_route(route, method)
      Tom::LOG.info "Merging with:"
      Tom::LOG.info "  -> #{merger}"
      merger.new.merge env, responses
    end



    #
    #  Extract the route/request uri and the method from a
    #  rack env
    #
    def self.route_and_method(env)
      [env["REQUEST_PATH"],
       env["REQUEST_METHOD"].downcase.to_sym]
    end

  end
end
